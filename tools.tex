%!TEX root = vmf_main.tex

\section{Tools}

Over the course of desigining VMF, a converter has been developed to convert existing files in a variety of formats to and from VMF. This converter is implemented in Python and is built upon the music21 toolkit \citep*{CuAr10}.

\subsection{Music21 Toolkit}

The music21 toolkit is a software library implemented in the Python programming language designed as a tool for computational musicology. The main service provided to VMF by music21 is the rich object model \citep*{ArCu11} for representing music at runtime. This object model is a key component of the converter is it forms a common bridge between VMF and any other format which is supported by music21 (ex. MIDI, MusicXML, Humdrum, ect.).

Aside from conversion, because VMF can be read into music21's object model, music contained in VMF files can be manipulated and examined using music21 for any use case which it already supports. This provides huge advantages to a developer who is already familiar with this toolkit and would like to work with VMF files with or without other files from a variety of formats in a common fashion.

\subsection{Converter}

The converter tool which has been developed for VMF is open source under an MIT license, and can be found on \href{https://github.com/project-schumann/vmf-converter}{Github}. The converter itself is developed in Python as a plugin for the music21 toolkit. Since music21 is extensible by design, providing this converter as a plugin is the best option as it provides support for VMF to and from any format that music21 currently supports, and may support in the future through other converter plugins. To develop this plugin, all that was needed was instructions for music21 on how to read and write a VMF file.

In order to convert to VMF, there is a pre-processing step that must be executed in order to obtain the necessary information to reside in the file's header. In this pre-processing step, the score being converted must be scanned in order to find the largest common rhythmic subdivison which would allow all rhythmic content to be accurately encoded, the largest chord which appears in the score, and the total number of parts and voices contained in the score. Once this information is found, music can start being converted by traversing the score. For every note, chord, or rest encountered, the number of tick vectors necessary to represent it must be calculated and written to memory with the appropriate dynamic, articulation, and pitch dimensions set. For example, if a quarter note is encountered and the tick value is equivalent to one sixteenth note, then four tick vectors will be written to the file. This process of converting notes and rests to a series of vectors is continued to the end of the piece. Additionally, every time a time signature, key signature or metronome marking is encountered, it should also be added to the header of the file with the appropriate displacement as its key. Once this process is complete, the header and vector collection can be added to a JSON object according to the structure of the format and saved.

Reading a VMF file is done in a similar way to writing, but there is no pre-processing step necessary. Once the JSON contained within the VMF file is parsed, the structure of the score can be defined using the number of parts and voices recorded in the header. Since each tick in a polyphonic work is structured as a matrix, to isolate each part, a column of this matrix can be extracted for interpretation. With a single part extracted, it can be iterated through to read the contents of each tick. By paying special attention to the contents of each attack dimension, the rhythmic content of the score can be reconstructed while assigning dynamic, articulation and pitch information to each note as each tick is processed. Once a part has been processed, the rest of the voices can be read by repeating the same procedure by simply extracting each subsequent column from every tick matrix.